### High-Level Architecture Analysis Prompt ###

Based on the codebase analysis, create a Mermaid diagram that represents the system's high-level architecture. Focus on:

1. Core Business Domains
- Identify main business capabilities
- Group related functionality
- Highlight domain boundaries

2. Architectural Layers
- Frontend/UI components
- Business logic/Services
- Data access/Storage
- Infrastructure components

3. Key Integration Points
- External system dependencies
- APIs and interfaces
- Message queues/Event buses
- Third-party services

4. Cross-Cutting Concerns
- Authentication/Authorization
- Logging/Monitoring
- Configuration management
- Common utilities

External & Cloud Infrastructure

5. Cloud provider services (AWS/Azure/GCP)
- SaaS integrations
- Managed services
- Service mesh/connectivity
- Containerization platforms
- Scalability components


Group CloudProvider services in one block.
### Diagram Requirements ###

Generate a Mermaid diagram using this structure:

```mermaid
graph TB
    %% Subgraph for Core Business Domain
    subgraph CoreDomain[Core Business Domain]
        Core1[Domain Service 1]
        Core2[Domain Service 2]
    end
    
    %% Subgraph for Infrastructure
    subgraph Infrastructure[Infrastructure Layer]
        Infra1[Database]
        Infra2[Caching]
        Infra3[Message Queue]
    end
    
    %% Subgraph for External Systems
    subgraph External[External Systems]
        Ext1[Third Party API]
        Ext2[External Service]
    end
    
    %% Cross-cutting concerns
    subgraph Utilities[Cross-Cutting Concerns]
        Util1[Logging]
        Util2[Authentication]
    end
    
    %% Relationships
    Core1 --> Core2
    Core2 --> Infra1
    Core2 --> Infra2
    Core1 --> Ext1
    Util2 -.-> Core1
    Util2 -.-> Core2
    Util1 -.-> Core1
    Util1 -.-> Core2
```

### Analysis Instructions ###

1. Component Identification:
   - Extract key namespaces/packages
   - Identify primary services/modules
   - Map external dependencies
   - Note cross-cutting concerns

2. Relationship Analysis:
   - Map direct dependencies (solid lines)
   - Identify indirect dependencies (dashed lines)
   - Note data flow directions
   - Highlight critical paths

3. Grouping Guidelines:
   - Group by business capability
   - Separate infrastructure concerns
   - Isolate external integrations
   - Cluster related utilities

4. Style Conventions:
   - Core business logic: Pink fill
   - Infrastructure: Light blue fill
   - External systems: Light green fill
   - Utilities: Light yellow fill
   - Use double borders for critical components
   - Dashed lines for loose coupling
   - Solid lines for direct dependencies


Note: The above example structure should be automatically replaced with an actual diagram based on the codebase analysis below.

## The codebase:

<codebase>

<toc>
## Table of Contents

{% for file in files %}{{ file.path }}
{% endfor %}
</toc>

<code>
{% for file in files %}
## {{ file.path }}

```{{ file.language }}
{{ file.content }}
```

{% endfor %}
</code>

</codebase>